<!DOCTYPE html>
<html>
<head>
  <title>Papers</title>
  <link href='../style.css' rel='stylesheet'>
  <meta name=viewport content="width=device-width, initial-scale=1">
</head>

<body>
  <div id="container">
<style>
  table {
    border-collapse: collapse;
  }

  th, td {
    border: 2px solid black;
    min-width: 50px;
    padding: 4pt;
  }
</style>

<p hidden>
$\newcommand{\set}[1]{\left\{#1\right\}}$ $\newcommand{\setst}[2]{\left\{#1 \,\middle|\, #2\right\}}$ $\newcommand{\lam}[2]{\lambda #1.\&gt;#2}$ $\newcommand{\typedlam}[3]{\lam{#1\in#2}{#3}}$ $\newcommand{\denote}[1]{[ \! [{#1}] \! ]}$ $\newcommand{\domain}{\textbf{D}}$ $\newcommand{\relations}{\mathcal{R}}$ $\newcommand{\fields}{\mathcal{U}}$ $\newcommand{\getfield}[2]{t \cdot A}$ $\newcommand{\Tuple}{Tuple}$ $\newcommand{\UTuple}{U\text{-}Tuple}$ $\newcommand{\TupleLoc}{TupleLoc}$ $\newcommand{\FieldLoc}{FieldLoc}$ $\newcommand{\select}[1]{\sigma_{#1}}$ $\newcommand{\project}[1]{\pi_{#1}}$ $\newcommand{\join}{\bowtie}$ $\newcommand{\setdiff}{\backslash}$
</p>

<h1 id="provenance-in-databases-why-how-and-where"><a href="https://scholar.google.com/scholar?cluster=14688264622623487965">Provenance in Databases: Why, How, and Where</a></h1>
<h2 id="chapter-1-introduction">Chapter 1: Introduction</h2>
<p><strong>Data provenance</strong>, also known as <strong>data lineage</strong>, describes the origin and history of data as it is moved, copied, transformed, and queried in a data system. In the context of relational databases, provenance will allow us to point at a tuple (or part of a tuple) in the output of a query and ask why or how it got there. In this book, we’ll study three forms of provenance known as <em>why-provenance</em>, <em>how-provenance</em>, and <em>where-provenance</em>.</p>
<h3 id="lineage">Lineage</h3>
<p>The <strong>lineage</strong> of tuple $t$ in the output of evaluating query $Q$ against database instance $I$ is a subset of the tuples in $I$ (known as a <strong>witness</strong>) that are sufficient for $t$ to appear in the output. Lineage is best explained through an example. Consider the following relations $R$</p>
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">$t_1$</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">$t_2$</td>
<td align="left">2</td>
</tr>
</tbody>
</table>
<p>and $S$</p>
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">A</th>
<th align="left">B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">$t_3$</td>
<td align="left">1</td>
<td align="left">blue</td>
</tr>
<tr class="even">
<td align="left">$t_4$</td>
<td align="left">1</td>
<td align="left">blue</td>
</tr>
<tr class="odd">
<td align="left">$t_5$</td>
<td align="left">1</td>
<td align="left">red</td>
</tr>
<tr class="even">
<td align="left">$t_6$</td>
<td align="left">2</td>
<td align="left">blue</td>
</tr>
<tr class="odd">
<td align="left">$t_7$</td>
<td align="left">2</td>
<td align="left">red</td>
</tr>
</tbody>
</table>
<p>and consider the query $Q$:</p>
<pre><code>SELECT R.A
FROM   R, S
WHERE  R.A = S.A AND S.B = blue</code></pre>
<p>The result of evaluating query $Q$ is:</p>
<table>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">$t_8$</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">$t_9$</td>
<td align="left">2</td>
</tr>
</tbody>
</table>
<p>The lineage of $t_8$ is $\set{t_1, t_3, t_4}$, and the lineage of $t_9$ is $\set{R(t_2), S(t_6)}$. While the lineage of a tuple $t$ is sufficient for $t$ to appear in the output, the lineage is not necessary. For example, the lineage of $t_8$ does not capture the fact that $t_3$ and $t_4$ do not both have to appear in the input for $t_8$ to appear in the output. In fact, for a given output tuple $t$ there could be an exponential number of sufficient (but not necessary) witnesses for it.</p>
<h3 id="why-provenance">Why-Provenance</h3>
<p><strong>Why-provenance</strong> is similar to lineage but tries to avoid considering an exponential number of potential witnesses. Instead, it focuses on a restricted set of witnesses known as the <strong>witness basis</strong>. For example, the witness basis of $t_8$ is $\set{\set{t_1, t_3}, \set{t1_, t_4}}$. A <strong>minimal witness basis</strong> is a witness basis consisting only of minimal witnesses. That is, it won’t include two witnesses $w$ and $w’$ where $w \subseteq w’$. The witness basis of two equivalent queries might differ, but the two queries are guaranteed to share the same minimal witness basis.</p>
<h3 id="how-provenance">How-Provenance</h3>
<p>Given an output tuple $t$, why-provenance provides witnesses that prove $t$ should appear in the output. However, why-provenance does not tell us <em>how</em> $t$ was formed from a witness. <strong>How-provenance</strong> uses a <strong>provenance semiring</strong> to hint at how an tuple was derived. The semiring consists of polynomials over tuple ids. The polynomial $t^2 + t \cdot t’$ hints at two derivations: one which uses $t$ twice and one which uses $t$ and $t’$.</p>
<h3 id="where-provenance">Where-Provenance</h3>
<p><strong>Where-provenance</strong> is very similar to why-provenance except that we’ll now point at a particular entry (or <strong>location</strong>) of an output tuple $t$ and ask which input locations it was copied from. For example, the where-provenance of the $A$ entry of tuple $t_8$ is the $A$ entry of tuple $t_3$ or $t_4$.</p>
<h3 id="eager-vs-lazy">Eager vs Lazy</h3>
<p>There are two main ways to implement data lineage:</p>
<ol style="list-style-type: decimal">
<li>an <strong>eager</strong> (or <strong>bookkeeping</strong> or <strong>annotating</strong>) approach, and</li>
<li>a <strong>lazy</strong> (or <strong>non-annotating</strong>) approach.</li>
</ol>
<p>In the eager approach, tuples are annotated and their annotations are propagated through the evaluation of a query. The lineage of an output tuple can then be directly determined using its annotations. In the lazy approach, tuples are not annotated. Instead, the lineage of a tuple must be derived by inspecting the query and input database.</p>
<h3 id="notational-preliminaries">Notational Preliminaries</h3>
<ul>
<li>Let $\domain = \set{d_1, \ldots, d_n}$ be a finite domain of data values.</li>
<li>Let $\fields$ be a collection of <strong>field names</strong> (or <strong>attribute names</strong>) where $U, V \subseteq \fields$.</li>
<li>A <strong>record</strong> (or <strong>tuple</strong>) $t, u$ is a function $U \to \domain$ written $(A_1:d_1, \ldots, A_n:d_n)$.</li>
<li>A tuple whose domain is $U$ is said to be a <strong>$U$-tuple</strong>.</li>
<li>$\Tuple$ is the set of all tuples and $\UTuple$ is the set of all $U$-tuples.</li>
<li>We write $\getfield{t}{A}$ as a shorthand for $t(A)$.</li>
<li>We write $t[U]$ as a shorthand for the restriction of $t$ to $U$: $\typedlam{A}{U}{\getfield{t}{A}}$.</li>
<li>We write $t[A \mapsto B]$ for the renaming of field $A$ to $B$.</li>
<li>We write $(A: e(A))$ as a shorthand for $\typedlam{A}{U}{e(A)}$.</li>
<li>A <strong>relation</strong> (or <strong>table</strong>) $r: U$ is a finite set of tuples over $U$.</li>
<li>$\relations$ is a finite collection of <strong>relation names</strong>.</li>
<li>A schema $\textbf{R}$ is a function $(R_1:U_1, \ldots, R_n:U_n)$ from $\relations$ to $2^{\fields}$.</li>
<li>A <strong>database</strong> (or <strong>instance</strong>) $I: \textbf{R}$ is a function mapping each $R_i:U_i \in \textbf{R}$ to a relation $r_i$ over $U_i$.</li>
<li>A <strong>tuple location</strong> is a tuple tagged with a relation name and is written $(R, t)$. We write $\TupleLoc = \relations \times \Tuple$ for the set of all tagged tuples.</li>
<li>We can view a database $I$ as $\setst{(R, t)}{t \in I(R)} \subseteq \TupleLoc$.</li>
<li>A <strong>field location</strong> is a triple $(R, t, A)$ which refers to a particular field or a particular tuple. We let $\FieldLoc$ be the set of all field locations.</li>
<li>Letting $Y_{\bot} = Y \cup \set{\bot}$, we’ll view a partial function $f: X \rightharpoonup Y$ as a total function $f: X \to Y_{\bot}$.</li>
</ul>
<p>Finally, this is the syntax of <strong>monotone relation algebra</strong>:</p>
<pre><code>$$
\begin{array}{rrl}
  Q &amp; ::= &amp; R \\
    &amp; |   &amp; \set{t} \\
    &amp; |   &amp; \sigma_{\theta}(Q) \\
    &amp; |   &amp; \pi_{U}(Q) \\
    &amp; |   &amp; Q_1 \bowtie Q_2 \\
    &amp; |   &amp; Q_1 \cup Q_2 \\
    &amp; |   &amp; \rho_{A \mapsto B}(Q) \\
\end{array}
$$</code></pre>
<p>This is the semantics:</p>
<pre><code>$$
\begin{array}{rrl}
  \denote{R}(I) &amp; = &amp;
    \set{t} \\
  \denote{\set{t}}(I) &amp; = &amp;
    I(R) \\
  \denote{\sigma_{\theta}(Q)}(I) &amp; = &amp;
    \setst{t \in \denote{Q}(I)}{\theta(t)} \\
  \denote{\pi_{U}(Q)}(I) &amp; = &amp;
    \setst{t[U]}{t \in \denote{Q}(I)} \\
  \denote{Q_1 \bowtie Q_2}(I) &amp; = &amp;
    \setst{t}{t[U_1] \in \denote{Q_1}(I), t[U_2] \in \denote{Q_2}(I)} \\
  \denote{Q_1 \cup Q_2}(I) &amp; = &amp;
    \denote{Q_1}(I) \cup \denote{Q_2}(I) \\
  \denote{\rho_{A \mapsto B}(Q)}(I) &amp; = &amp;
    \setst{t[A \mapsto B]}{t \in \denote{Q}(I)} \\
\end{array}
$$</code></pre>
<p>Often, we will omit the denotational brackets $\denote{\cdot}$ and abbreviate $\denote{Q}(I)$ as $Q(I)$. We will also sometimes denote a grouping by columns $G$ as $\alpha_G(Q)$.</p>
<h2 id="chapter-2-why-provenance">Chapter 2: Why-Provenance</h2>
<h3 id="lineage-1">Lineage</h3>
<p hidden>
$\newcommand{\Rs}{R_1, \ldots, R_n}$ $\newcommand{\Rprimes}{R_1’, \ldots, R_n’}$ $\newcommand{\Qs}{Q_1, \ldots, Q_n}$ $\newcommand{\Ss}{S_1, \ldots, S_n}$ $\newcommand{\lineage}{\textsf{Lineage}}$ $\newcommand{\blue}{\text{blue}}$ $\newcommand{\red}{\text{red}}$
</p>

<p>First, we review lineage. Let $Op$ be a relation operator over input relations $(\Rs)$. The <strong>lineage</strong> of a tuple $t \in Op(\Rs)$ is a subset $(\Rprimes)$ of $(\Rs)$ such that:</p>
<ol style="list-style-type: decimal">
<li>$Op(\Rprimes) = \set{t}$;</li>
<li>For all $i \in [n]$ and for all $t_i \in R_i’$, $Op(R_1’, \ldots, \set{t_i}, \ldots, R_n’) \neq \emptyset$; and</li>
<li>$(\Rprimes)$ is maximal among subsets satisfying 1 and 2.</li>
</ol>
<p>1 ensures the lineage is relevant to $t$, 2 ensures that no irrelevant tuples are included, and 3 ensures the lineage is “complete”. Given the definition of lineage, we can compute it. Let $\lineage(t, Op(\Rs))$ be the lineage of tuple $t \in Op(\Rs)$.</p>
<pre><code>$$
\begin{align*}
  \lineage(t, \select{\theta}(R))
    &amp;= (\set{t}) \\
  \lineage(t, \project{U}(R))
    &amp;= (\setst{t&#39; \in R}{t&#39;[U] = t}) \\
  \lineage(t, R_1 \join \cdots \join R_n)
    &amp;= \left.(\setst{t_i \in R_i}{t[U_i] = t_i})\right\vert_{i \in [n]} \\
  \lineage(t, R_1 \cup \cdots \cup R_n)
    &amp;= \left.(\setst{t_i \in R_i}{t = t_i})\right\vert_{i \in [n]} \\
  \lineage(t, R_1 \setdiff R_2)
    &amp;= (\set{t}, R_2) \\
  \lineage(t, \alpha_G(R))
    &amp;= (\setst{t&#39; \in R}{t[G] = t&#39;[G]})
\end{align*}
$$</code></pre>
<p>Next, consider a query $Op(\Qs)$ run on a database $I$. Let $S_i = Q_i(I)$ and let $\lineage(t, Op(\Qs), I)$ be the lineage of $t$ in $Op(\Qs)(I)$.</p>
<pre><code>$$
\lineage(t, Op(\Qs), I) =
  \bigcup_{S_i(t&#39;) \in \lineage(t, Op(\Ss))} \lineage(S_i(t&#39;), S_i)
$$</code></pre>
<p>Consider again the relations $R$ and $S$ and the query $Q$ from above. We can express $Q$ in the relation algebra—$Q = \project{A}(\select{S.B = \text{blue}}(R \join S))$—and compute the lineage of $t_8$.</p>
<pre><code>$$
\begin{align*}
  \lineage(t_8, \project{A}(\select{S.a=\blue}(R(I) \join S(I))))
    &amp;= \set{(1, blue)} \\
  \lineage(\set{(1, blue)}, \select{S.a=\blue}(R(I) \join S(I)))
    &amp;= \set{(1, blue)} \\
  \lineage(\set{(1, blue)}, R(I) \join S(I))
    &amp;= \set{\set{t_1}, \set{t_3, t_4}}
\end{align*}
$$</code></pre>
<h3 id="a-compositional-definition-of-lineage">A Compositional Definition of Lineage</h3>
<h3 id="why-provenance-1">Why-Provenance</h3>
<h2 id="chapter-3-how-provenance">Chapter 3: How-Provenance</h2>
<p>TODO</p>
<h2 id="chapter-4-where-provenance">Chapter 4: Where-Provenance</h2>
<p>TODO</p>
<h2 id="chapter-5-comparing-models-of-provenance">Chapter 5: Comparing Models of Provenance</h2>
<p>TODO</p>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        skipTags: ['script', 'noscript', 'style', 'textarea'],
      },
      messageStyle: "none",
    });
  </script>
  </div>
</body>
</html>
